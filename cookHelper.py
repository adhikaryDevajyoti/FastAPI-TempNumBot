from os import getenv, path
from bs4 import BeautifulSoup as bs
import json
import requests
import pandas as pd
import hashlib
import httpx

FAST = getenv("FASTSMS_API")
BOWER = getenv("BOWER_API")
TIGER = getenv("TIGER_API")

#File Address
MENU = "menuItems.json"
HASHEDMENU = "hashedMap.json"


class hashedList:

    def __init__(self, itemList: list) -> None:
        """Create and stores a list of service name with a 6 character unique hashed code to identify the product.
        This takes the argument of list of services(which is a dataframe in getListpfCodes Class.
        Usage : getServiceName(hashedCode)->Service Name if correct else return the same hashedCode"""
        self.name = itemList
        self.filePath = HASHEDMENU
        if path.isfile(self.filePath):
            with open(self.filePath, 'r') as f:
                self.hashedMap = json.load(f)
        else:
            self.hashedMap = self.hash()

    def hash(self):

        def simple_hash(string):
            """Hashes a string to a 6-character hexadecimal string.

          Args:
              string: The string to hash.

          Returns:
              A 6-character hexadecimal string representing the hash.
          """
            # Hash the string using md5
            hashed_value = hashlib.md5(string.encode()).hexdigest()
            # Truncate to the first 6 characters
            return hashed_value[:6]

        data = pd.DataFrame(self.name, columns=['Name'])
        data['ID'] = data['Name'].apply(simple_hash)
        data = {rows['ID']: rows['Name'] for _, rows in data.iterrows()}
        with open(self.filePath, 'w') as file:
            json.dump(data, file)
        return data

    def getServiceName(self, hashedCode: str) -> str:
        """
        Get the service name from the stored hashed code, and if no service name is found, it returns the same hashedCode
        args:
            hashedCode - The Hashed Code generated by the hash function, also stored in the local database
        returns:
            serviceName - The service name to be used in other functions
            """
        try:
            return str(self.hashedMap[hashedCode])
        except KeyError as k:
            return str(k)


class getPriceLists:
    """This will save the prices list of all the services from different server. The servers's prices are stored as dictionary, and can be used to fetch prices fast.
    This is to increase the speed of fetching prices
    """

    def __init__(self) -> None:
        self.fast = self.fastPrices()
        self.five = self._5SimPrices()
        self.bower = self.bowerPrices()
        self.tiger = self.tigerPrices()

    def fastPrices(self)->dict:
        fastsms = f"https://fastsms.su/stubs/handler_api.php"
        params = {
            "api_key": FAST,
            "action": "getPrices",
            "country": '22'
        }
        resp = requests.get(fastsms, params=params)
        if resp.status_code != 200:
            print(resp.text+str(resp.status_code))
            return {'non':'non'}
        ID = list(resp.json()['22'].keys())

        resp.json()['22']
        cost = []
        count = []
        for i in resp.json()['22'].values():
            cost.append(list(i.keys())[0])
            count.append(list(i.values())[0])

        fast = pd.DataFrame({'ID': ID, 'cost': cost, 'count': count})
        return fast.set_index('ID').to_dict(orient='index')

    def _5SimPrices(self):
        url = "https://5sim.net/v1/guest/products/india/any"
        header = {
            "Accept": "application/json",
            "Content-Type": "application/json",
        }
        resp = requests.get(url, headers=header)
        val = resp.json()
        df_5sim = pd.DataFrame.from_dict(val, orient='index')
        df_5sim.reset_index(inplace=True, names="Name")
        df_5sim.drop('Category', axis=1, inplace=True)
        df_5sim.columns = ['ID', 'count', 'cost']
        return df_5sim.set_index('ID').to_dict(orient='index')

    def tigerPrices(self):
        url = "https://api.tiger-sms.com/stubs/handler_api.php"
        params = {
            'country': '22',
            'action': 'getPrices',
            'api_key': TIGER
        }
        resp = requests.get(url, params=params)

        df_tiger = resp.json()['22']
        return df_tiger

    def bowerPrices(self):
        url = "https://smsbower.com/stubs/handler_api.php"
        params = {
            'country': '22',
            'action': 'getPrices',
            'api_key': BOWER
        }
        resp = requests.get(url, params=params)

        df_bower = resp.json()['22']
        return df_bower


class getListsofCodes:

    def __init__(self, address:str,gpl:getPriceLists):
        """This will help to get the valid list of service code across different servers. This stores the information in the local to save time for processing the data for the first time, and will download again if the file doesnot exist"""
        self.gpl = gpl
        self.address = address
        if path.isfile(address):
            self.serviceMenu = self.loadAllServiceList()
        else:
            self.serviceMenu = self.buildJson()


    def _5Sim(self):
        url = "https://5sim.net/v1/guest/products/india/any"
        header = {
            "Accept": "application/json",
            "Content-Type": "application/json",
        }
        resp = requests.get(url, headers=header)
        val = resp.json()
        df_5sim = pd.DataFrame.from_dict(val, orient='index')
        df_5sim.reset_index(inplace=True,names="Name")
        df_5sim['ID 5Sim'] = df_5sim['Name']
        df_5sim.drop(columns=['Category','Qty','Price'],inplace=True)
        return df_5sim

    def fast(self):
        fastsms = "https://fastsms.su/stubs/handler_api.php"
        params = {
            "api_key":FAST,
            'action':"getServices",
            'country':'22'
            }

        resp = requests.get(fastsms,params=params)
        df_fast = pd.DataFrame.from_dict(resp.json(), orient='index',columns=['Name'])
        df_fast.reset_index(names='ID Fast',inplace=True)
        return df_fast

    def tiger(self):

        def get_soup(url):
          response = requests.get(url)

          if response.status_code == 200:
            html_content = response.text
            soup = bs(html_content, 'html.parser')
          else :
            soup = None
          return soup
        url = "https://tiger-sms.com/api"
        soup_tiger = get_soup(url)
        services_list = soup_tiger.find(id='service').find_all(class_="api-item-service")
        properList = []
        for service in services_list:
            row = []
            row.append(service.find('p',class_='api-item-p').text)
            row.append(service.find('p',class_='').text)
            properList.append(row)
        df_tiger = pd.DataFrame(data=properList,columns=['Name','ID Tiger'])
        return df_tiger

    def bower(self):
          # URL of the page to scrape
          url = "https://smsbower.com/api"

          # Set headers to mimic a browser request
          headers = {
              "User-Agent":
              "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
          }

          # Send a GET request to the URL using httpx
          with httpx.Client() as client:
              response = client.get(url, headers=headers)

          # Check if the request was successful
          if response.status_code == 200:
              # Parse the page content with BeautifulSoup
              soup = bs(response.content, "html.parser")

              # Find the table with id='collapseExample4'
              table_div = soup.find(id="collapseExample4")

              if table_div:
                  # Find the table element within the div
                  table = table_div.find("table")

                  # Extract table headers
                  headers = [header.text.strip() for header in table.find_all("th")]
                  # Extract table rows
                  name = []
                  id = []
                  for row in table.find_all("tr")[1:]:  # Skip the header row
                      cells = row.find_all("td")
                      row_data = [cell.text.strip() for cell in cells]
                      name.append(row_data[0])
                      id.append(row_data[1])
                  bower = pd.DataFrame({'Name':name,'ID Bower':id})
                  return bower

              else:
                  print("No table found with id='collapseExample4'")
          else:
              print(f"Failed to retrieve the page. Status code: {response.status_code}")
          return pd.DataFrame({'Name':[],'ID Bower':[]})

    def merge(self):
        def countDuplicates(df:pd.DataFrame,col='Name'):
          temp = df[df[col].duplicated()]
          if temp.size>0:
              print("found duplicate",temp)
          return temp.size

        def delDuplicates(df:pd.DataFrame,rightDict:dict,
                           colToSet:str=""):
           temp = pd.DataFrame(list(rightDict.keys()),columns=[colToSet])
           return df.merge(temp,'inner',on=colToSet)

        def repairing(df:pd.DataFrame,correctDict:dict,colToSet:str):   
          if countDuplicates(df)>0:
            df = delDuplicates(df,correctDict,colToSet)
            print('After Duplicate Removal left,which will be dropped')
            countDuplicates(df)
          return df.drop_duplicates(subset=['Name'], keep='first')
         


        five = repairing(self._5Sim(),self.gpl.five,'ID 5Sim')
        fast = repairing(self.fast(),self.gpl.fast,'ID Fast')
        bower = repairing(self.bower(),self.gpl.bower,'ID Bower')
        tiger = repairing(self.tiger(),self.gpl.tiger,'ID Tiger')

        merged = five.merge(fast,'outer').merge(tiger,'outer').merge(bower,'outer')
        merged = merged.sort_values('Name').set_index('Name')
        return merged

    
    def repair(self):
        """It would check for the service codes and remove which were invalid"""
        def checkPriceFast(code):
            """Check if the price of a product is there in Fast SMS"""
            base_url = "https://fastsms.su/stubs/handler_api.php"
            params = {
                "api_key": FAST,
                "action": "getPrices",
                "service": code,
                "country": '22'
            }
            resp = requests.get(base_url, params=params)
            if resp.status_code == 200:
                try:
                    return len(resp.json()) > 0
                except:
                    return resp.content
            else:
                return False

        def checkPriceBower(code):
            """Check if the price of a product is there in Bower SMS"""
            base_url = "https://smsbower.com/stubs/handler_api.php"
            params = {
                "api_key": BOWER,
                "action": "getPrices",
                "service": code,
                "country": '22'
            }
            resp = requests.get(base_url, params=params)
            if resp.status_code == 200:
                try:
                    return len(resp.json()) > 0
                except:
                    return resp.content
            else:
                return False

        indexed = self.merge()

        duplicates = indexed[indexed.index.duplicated()]
        #print(duplicates.index)
        for i in duplicates.index:
            t = indexed.loc[i].copy()
            name = i
            indexed.drop([i], inplace=True)
            if t['ID Tiger'].any():
                keep = (t[t['ID Tiger'] != t['ID Fast']])
                # print(keep.values)
                indexed.loc[name] = keep.values[0]
            else:
                t.loc[:, 'fast'] = t['ID Fast'].apply(checkPriceFast)
                t.loc[:, 'bower'] = t['ID Fast'].apply(checkPriceBower)
                # print(t)
                try:
                    idFast = str(t[t.fast == True]['ID Fast'].values[0])
                except IndexError:
                    idFast = None
                try:
                    idBower = str(t[t.bower == True]['ID Fast'].values[0])
                except IndexError:
                    idBower = None

                id5sim = t.loc[i, 'ID 5Sim'].values[0]
                indexed.loc[name] = [None, idFast, id5sim, idBower]
        return indexed

    def buildJson(self):
        data = self.repair()
        data.fillna("None--", inplace=True)
        save_json = data.replace("None--", None).to_dict('index')

        # Iterate through inner dictionaries
        for outer_key, inner_dict in save_json.items():
            # Iterate through key-value pairs in the inner dictionary
            for key, value in list(inner_dict.items()):
                if value is None:
                    del inner_dict[key]
                    
        with open(self.address, 'w') as f:
            json.dump(save_json, f)
        return save_json

    def loadAllServiceList(self):
        with open(self.address, 'r') as file:
            data = json.load(file)
        return data

    def getServiceCodes(self, serviceName: str)->dict:
        try:
            return self.serviceMenu[serviceName]
        except KeyError:
            return {'Service Name Not Found':serviceName}


priceLists = getPriceLists()
servicesMenu = getListsofCodes(MENU,priceLists)
hashMap = hashedList(list(servicesMenu.serviceMenu.keys()))

def Test(hashedCode:str="cbc32a"):
    serviceName = hashMap.getServiceName(hashedCode)
    codes = servicesMenu.getServiceCodes(serviceName)
    print(serviceName)
    print(codes)
    print(priceLists.fast['smc'])

def getPriceFromHashCode(hashCode:str):
    serviceName = hashMap.getServiceName(hashCode)
    if hashCode == serviceName:
        return {"Error":"Wrong Code:"+hashCode}
    serviceCodes = servicesMenu.getServiceCodes(serviceName)
    if len(serviceCodes)<2:
        return serviceCodes
    prices = {}
    def priceForIndividual(serviceCodeKey:str,priceDict:dict):
        key = serviceCodeKey
        #print(key,type(priceDict),serviceCodes[key])
        try:
            if serviceCodes[key] is not None:
                prices[key] = priceDict[serviceCodes[key]]
        except KeyError as k:
            print(k)
    
    maps ={'ID Tiger': priceLists.tiger,
           'ID Fast': priceLists.fast,
           'ID 5Sim': priceLists.five,
           'ID Bower': priceLists.bower}
    for key, value in maps.items():
        # print(key,type(value))
        priceForIndividual(key,value)
    return prices
    
def getPriceFromName(serviceName:str):
    serviceCodes = servicesMenu.getServiceCodes(serviceName)
    if len(serviceCodes)<2:
        return serviceCodes
    prices = {}
    def priceForIndividual(serviceCodeKey:str,priceDict:dict):
        key = serviceCodeKey
        #print(key,type(priceDict),serviceCodes[key])
        try:
            if serviceCodes[key] is not None:
                prices[key] = priceDict[serviceCodes[key]]
        except KeyError as k:
            print(k)
    
    maps ={'ID Tiger': priceLists.tiger,
           'ID Fast': priceLists.fast,
           'ID 5Sim': priceLists.five,
           'ID Bower': priceLists.bower}
    for key, value in maps.items():
        # print(key,type(value))
        priceForIndividual(key,value)
    return prices
    
    
    


if __name__ == '__main__':
    Test()
    print("Testing Hash to Prices")
    print(getPriceFromHashCode("cbc32a"))